<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Active Record 关联 — Ruby on Rails 指南</title>
<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />

<link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />

<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">更多内容 <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        更多内容
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="http://rubyonrails.org/">综览</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/download">下载</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/deploy">部署</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">源码</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/screencasts">视频</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/documentation">文件</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/community">社群</a></li>
        <li class="more-info"><a href="http://weblog.rubyonrails.org/">Blog</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="回首页">Guides.rubyonrails.org</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">首页</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">指南目录</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
              <dl class="L">
                <dt>入门</dt>
                <dd><a href="getting_started.html">Rails 入门</a></dd>
                <dt>模型</dt>
                <dd><a href="active_record_basics.html">Active Record 基础</a></dd>
                <dd><a href="active_record_migrations.html">Active Record 数据库迁移</a></dd>
                <dd><a href="active_record_validations.html">Active Record 数据验证</a></dd>
                <dd><a href="active_record_callbacks.html">Active Record 回调</a></dd>
                <dd><a href="association_basics.html">Active Record 关联</a></dd>
                <dd><a href="active_record_querying.html">Active Record 查询</a></dd>
                <dt>视图</dt>
                <dd><a href="layouts_and_rendering.html">Rails 布局和视图渲染</a></dd>
                <dd><a href="form_helpers.html">Action View 表单帮助方法</a></dd>
                <dt>控制器</dt>
                <dd><a href="action_controller_overview.html">Action Controller 简介</a></dd>
                <dd><a href="routing.html">Rails 路由全解</a></dd>
              </dl>
              <dl class="R">
                <dt>深入</dt>
                <dd><a href="active_support_core_extensions.html">Active Support 核心扩展</a></dd>
                <dd><a href="i18n.html">Rails 国际化 API</a></dd>
                <dd><a href="action_mailer_basics.html">Action Mailer 基础</a></dd>
                <dd><a href="active_job_basics.html">Active Job 基础</a></dd>
                <dd><a href="security.html">Rails 安全指南</a></dd>
                <dd><a href="debugging_rails_applications.html">调试 Rails 程序</a></dd>
                <dd><a href="configuring.html">设置 Rails 程序</a></dd>
                <dd><a href="command_line.html">Rails 命令行</a></dd>
                <dd><a href="asset_pipeline.html">Asset Pipeline</a></dd>
                <dd><a href="working_with_javascript_in_rails.html">在 Rails 中使用 JavaScript</a></dd>
                <dd><a href="constant_autoloading_and_reloading.html">Constant Autoloading and Reloading</a></dd>
                <dt>扩展 Rails</dt>
                <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                <dd><a href="generators.html">客制与新建 Rails 产生器</a></dd>
                <dd><a href="rails_application_templates.html">Rails 应用程式模版</a></dd>
                <dt>贡献 Ruby on Rails</dt>
                <dd><a href="contributing_to_ruby_on_rails.html">贡献 Ruby on Rails</a></dd>
                <dd><a href="api_documentation_guidelines.html">API 文件准则</a></dd>
                <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails 指南准则</a></dd>
                <dt>维护方针</dt>
                <dd><a href="maintenance_policy.html">维护方针</a></dd>
                <dt>发布记</dt>
                <dd><a href="upgrading_ruby_on_rails.html">升级 Ruby on Rails</a></dd>
                <dd><a href="4_2_release_notes.html">Ruby on Rails 4.2 发布记</a></dd>
                <dd><a href="4_1_release_notes.html">Ruby on Rails 4.1 发布记</a></dd>
                <dd><a href="4_0_release_notes.html">Ruby on Rails 4.0 发布记</a></dd>
                <dd><a href="3_2_release_notes.html">Ruby on Rails 3.2 发布记</a></dd>
                <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1 发布记</a></dd>
                <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 发布记</a></dd>
                <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 发布记</a></dd>
                <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 发布记</a></dd>
              </dl>
          </div>
        </li>
        <!-- <li><a class="nav-item" href="//github.com/docrails-tw/wiki">参与翻译</a></li> -->
        <li><a class="nav-item" href="https://github.com/ruby-china/guides/blob/master/CONTRIBUTING.md">贡献</a></li>
        <li><a class="nav-item" href="credits.html">致谢</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">指南目录</option>
              <optgroup label="入门">
                  <option value="getting_started.html">Rails 入门</option>
              </optgroup>
              <optgroup label="模型">
                  <option value="active_record_basics.html">Active Record 基础</option>
                  <option value="active_record_migrations.html">Active Record 数据库迁移</option>
                  <option value="active_record_validations.html">Active Record 数据验证</option>
                  <option value="active_record_callbacks.html">Active Record 回调</option>
                  <option value="association_basics.html">Active Record 关联</option>
                  <option value="active_record_querying.html">Active Record 查询</option>
              </optgroup>
              <optgroup label="视图">
                  <option value="layouts_and_rendering.html">Rails 布局和视图渲染</option>
                  <option value="form_helpers.html">Action View 表单帮助方法</option>
              </optgroup>
              <optgroup label="控制器">
                  <option value="action_controller_overview.html">Action Controller 简介</option>
                  <option value="routing.html">Rails 路由全解</option>
              </optgroup>
              <optgroup label="深入">
                  <option value="active_support_core_extensions.html">Active Support 核心扩展</option>
                  <option value="i18n.html">Rails 国际化 API</option>
                  <option value="action_mailer_basics.html">Action Mailer 基础</option>
                  <option value="active_job_basics.html">Active Job 基础</option>
                  <option value="security.html">Rails 安全指南</option>
                  <option value="debugging_rails_applications.html">调试 Rails 程序</option>
                  <option value="configuring.html">设置 Rails 程序</option>
                  <option value="command_line.html">Rails 命令行</option>
                  <option value="asset_pipeline.html">Asset Pipeline</option>
                  <option value="working_with_javascript_in_rails.html">在 Rails 中使用 JavaScript</option>
                  <option value="constant_autoloading_and_reloading.html">Constant Autoloading and Reloading</option>
              </optgroup>
              <optgroup label="扩展 Rails">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">客制与新建 Rails 产生器</option>
                  <option value="rails_application_templates.html">Rails 应用程式模版</option>
              </optgroup>
              <optgroup label="贡献 Ruby on Rails">
                  <option value="contributing_to_ruby_on_rails.html">贡献 Ruby on Rails</option>
                  <option value="api_documentation_guidelines.html">API 文件准则</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Ruby on Rails 指南准则</option>
              </optgroup>
              <optgroup label="维护方针">
                  <option value="maintenance_policy.html">维护方针</option>
              </optgroup>
              <optgroup label="发布记">
                  <option value="upgrading_ruby_on_rails.html">升级 Ruby on Rails</option>
                  <option value="4_2_release_notes.html">Ruby on Rails 4.2 发布记</option>
                  <option value="4_1_release_notes.html">Ruby on Rails 4.1 发布记</option>
                  <option value="4_0_release_notes.html">Ruby on Rails 4.0 发布记</option>
                  <option value="3_2_release_notes.html">Ruby on Rails 3.2 发布记</option>
                  <option value="3_1_release_notes.html">Ruby on Rails 3.1 发布记</option>
                  <option value="3_0_release_notes.html">Ruby on Rails 3.0 发布记</option>
                  <option value="2_3_release_notes.html">Ruby on Rails 2.3 发布记</option>
                  <option value="2_2_release_notes.html">Ruby on Rails 2.2 发布记</option>
              </optgroup>
          </select>
        </li>
      </ul>
      </div>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Active Record 关联</h2><p>本文介绍 Active Record 中的关联功能。</p><p>读完本文，你将学到：</p>
<ul>
<li>如何声明 Active Record 模型间的关联；</li>
<li>怎么理解不同的 Active Record 关联类型；</li>
<li>如何使用关联添加的方法；</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94">为什么要使用关联</a></li>
<li>
<a href="#%E5%85%B3%E8%81%94%E7%9A%84%E7%B1%BB%E5%9E%8B">关联的类型</a>

<ul>
<li><a href="#belongs_to-%E5%85%B3%E8%81%94"><code>belongs_to</code> 关联</a></li>
<li><a href="#has_one-%E5%85%B3%E8%81%94"><code>has_one</code> 关联</a></li>
<li><a href="#has_many-%E5%85%B3%E8%81%94"><code>has_many</code> 关联</a></li>
<li><a href="#has_many-:through-%E5%85%B3%E8%81%94"><code>has_many :through</code> 关联</a></li>
<li><a href="#has_one-:through-%E5%85%B3%E8%81%94"><code>has_one :through</code> 关联</a></li>
<li><a href="#has_and_belongs_to_many-%E5%85%B3%E8%81%94"><code>has_and_belongs_to_many</code> 关联</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-belongs_to-%E8%BF%98%E6%98%AF-has_one">使用 <code>belongs_to</code> 还是 <code>has_one</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-has_many-:through-%E8%BF%98%E6%98%AF-has_and_belongs_to_many">使用 <code>has_many :through</code> 还是 <code>has_and_belongs_to_many</code></a></li>
<li><a href="#%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94">多态关联</a></li>
<li><a href="#%E8%87%AA%E8%BF%9E%E6%8E%A5">自连接</a></li>
</ul>
</li>
<li>
<a href="#%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">小技巧和注意事项</a>

<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6">缓存控制</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81">避免命名冲突</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%BC%8F">更新模式</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%85%B3%E8%81%94%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">控制关联的作用域</a></li>
<li><a href="#%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94">双向关联</a></li>
</ul>
</li>
<li>
<a href="#%E5%85%B3%E8%81%94%E8%AF%A6%E8%A7%A3">关联详解</a>

<ul>
<li><a href="#belongs_to-%E5%85%B3%E8%81%94%E8%AF%A6%E8%A7%A3"><code>belongs_to</code> 关联详解</a></li>
<li><a href="#has_one-%E5%85%B3%E8%81%94%E8%AF%A6%E8%A7%A3"><code>has_one</code> 关联详解</a></li>
<li><a href="#has_many-%E5%85%B3%E8%81%94%E8%AF%A6%E8%A7%A3"><code>has_many</code> 关联详解</a></li>
<li><a href="#has_and_belongs_to_many-%E5%85%B3%E8%81%94%E8%AF%A6%E8%A7%A3"><code>has_and_belongs_to_many</code> 关联详解</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%9B%9E%E8%B0%83">关联回调</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E6%89%A9%E5%B1%95">关联扩展</a></li>
</ul>
</li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="为什么要使用关联">1 为什么要使用关联</h3><p>模型之间为什么要有关联？因为关联让常规操作更简单。例如，在一个简单的 Rails 程序中，有一个顾客模型和一个订单模型。每个顾客可以下多个订单。没用关联的模型定义如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
end

class Order &lt; ActiveRecord::Base
end

</pre>
</div>
<p>假如我们要为一个顾客添加一个订单，得这么做：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order = Order.create(order_date: Time.now, customer_id: @customer.id)

</pre>
</div>
<p>或者说要删除一个顾客，确保他的所有订单都会被删除，得这么做：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@orders = Order.where(customer_id: @customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy

</pre>
</div>
<p>使用 Active Record 关联，告诉 Rails 这两个模型是有一定联系的，就可以把这些操作连在一起。下面使用关联重新定义顾客和订单模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, dependent: :destroy
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
end

</pre>
</div>
<p>这么修改之后，为某个顾客添加新订单就变得简单了：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order = @customer.orders.create(order_date: Time.now)

</pre>
</div>
<p>删除顾客及其所有订单更容易：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer.destroy

</pre>
</div>
<p>学习更多关联类型，请阅读下一节。下一节介绍了一些使用关联时的小技巧，然后列出了关联添加的所有方法和选项。</p><h3 id="关联的类型">2 关联的类型</h3><p>在 Rails 中，关联是两个 Active Record 模型之间的关系。关联使用宏的方式实现，用声明的形式为模型添加功能。例如，声明一个模型属于（<code>belongs_to</code>）另一个模型后，Rails 会维护两个模型之间的“主键-外键”关系，而且还向模型中添加了很多实用的方法。Rails 支持六种关联：</p>
<ul>
<li><code>belongs_to</code></li>
<li><code>has_one</code></li>
<li><code>has_many</code></li>
<li><code>has_many :through</code></li>
<li><code>has_one :through</code></li>
<li><code>has_and_belongs_to_many</code></li>
</ul>
<p>在后面的几节中，你会学到如何声明并使用这些关联。首先来看一下各种关联适用的场景。</p><h4 id="belongs_to-关联">2.1 <code>belongs_to</code> 关联</h4><p><code>belongs_to</code> 关联创建两个模型之间一对一的关系，声明所在的模型实例属于另一个模型的实例。例如，如果程序中有顾客和订单两个模型，每个订单只能指定给一个顾客，就要这么声明订单模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer
end

</pre>
</div>
<p><img src="images/belongs_to.png" alt="belongs_to 关联"></p><div class="note"><p>在 <code>belongs_to</code> 关联声明中必须使用单数形式。如果在上面的代码中使用复数形式，程序会报错，提示未初始化常量 <code>Order::Customers</code>。因为 Rails 自动使用关联中的名字引用类名。如果关联中的名字错误的使用复数，引用的类也就变成了复数。</p></div><p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateOrders &lt; ActiveRecord::Migration
  def change
    create_table :customers do |t|
      t.string :name
      t.timestamps
    end

    create_table :orders do |t|
      t.belongs_to :customer
      t.datetime :order_date
      t.timestamps
    end
  end
end

</pre>
</div>
<h4 id="has_one-关联">2.2 <code>has_one</code> 关联</h4><p><code>has_one</code> 关联也会建立两个模型之间的一对一关系，但语义和结果有点不一样。这种关联表示模型的实例包含或拥有另一个模型的实例。例如，在程序中，每个供应商只有一个账户，可以这么定义供应商模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account
end

</pre>
</div>
<p><img src="images/has_one.png" alt="has_one 关联"></p><p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateSuppliers &lt; ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end

</pre>
</div>
<h4 id="has_many-关联">2.3 <code>has_many</code> 关联</h4><p><code>has_many</code> 关联建立两个模型之间的一对多关系。在 <code>belongs_to</code> 关联的另一端经常会使用这个关联。<code>has_many</code> 关联表示模型的实例有零个或多个另一个模型的实例。例如，在程序中有顾客和订单两个模型，顾客模型可以这么定义：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<div class="note"><p>声明 <code>has_many</code> 关联时，另一个模型使用复数形式。</p></div><p><img src="images/has_many.png" alt="has_many 关联"></p><p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateCustomers &lt; ActiveRecord::Migration
  def change
    create_table :customers do |t|
      t.string :name
      t.timestamps
    end

    create_table :orders do |t|
      t.belongs_to :customer
      t.datetime :order_date
      t.timestamps
    end
  end
end

</pre>
</div>
<h4 id="has_many-:through-关联">2.4 <code>has_many :through</code> 关联</h4><p><code>has_many :through</code> 关联经常用来建立两个模型之间的多对多关联。这种关联表示一个模型的实例可以借由第三个模型，拥有零个和多个另一个模型的实例。例如，在看病过程中，病人要和医生预约时间。这中间的关联声明如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Physician &lt; ActiveRecord::Base
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment &lt; ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient &lt; ActiveRecord::Base
  has_many :appointments
  has_many :physicians, through: :appointments
end

</pre>
</div>
<p><img src="images/has_many_through.png" alt="has_many :through 关联"></p><p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateAppointments &lt; ActiveRecord::Migration
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end

</pre>
</div>
<p>连接模型中的集合可以使用 API 关联。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
physician.patients = patients

</pre>
</div>
<p>会为新建立的关联对象创建连接模型实例，如果其中一个对象删除了，相应的记录也会删除。</p><div class="warning"><p>自动删除连接模型的操作直接执行，不会触发 <code>*_destroy</code> 回调。</p></div><p><code>has_many :through</code> 还可用来简化嵌套的 <code>has_many</code> 关联。例如，一个文档分为多个部分，每一部分又有多个段落，如果想使用简单的方式获取文档中的所有段落，可以这么做：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Document &lt; ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section &lt; ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end

class Paragraph &lt; ActiveRecord::Base
  belongs_to :section
end

</pre>
</div>
<p>加上 <code>through: :sections</code> 后，Rails 就能理解这段代码：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@document.paragraphs

</pre>
</div>
<h4 id="has_one-:through-关联">2.5 <code>has_one :through</code> 关联</h4><p><code>has_one :through</code> 关联建立两个模型之间的一对一关系。这种关联表示一个模型通过第三个模型拥有另一个模型的实例。例如，每个供应商只有一个账户，而且每个账户都有一个历史账户，那么可以这么定义模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account
  has_one :account_history, through: :account
end

class Account &lt; ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory &lt; ActiveRecord::Base
  belongs_to :account
end

</pre>
</div>
<p><img src="images/has_one_through.png" alt="has_one :through 关联"></p><p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateAccountHistories &lt; ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end

</pre>
</div>
<h4 id="has_and_belongs_to_many-关联">2.6 <code>has_and_belongs_to_many</code> 关联</h4><p><code>has_and_belongs_to_many</code> 关联之间建立两个模型之间的多对多关系，不借由第三个模型。例如，程序中有装配体和零件两个模型，每个装配体中有多个零件，每个零件又可用于多个装配体，这时可以按照下面的方式定义模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Assembly &lt; ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

</pre>
</div>
<p><img src="images/habtm.png" alt="has_and_belongs_to_many 关联"></p><p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateAssembliesAndParts &lt; ActiveRecord::Migration
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end

</pre>
</div>
<h4 id="使用-belongs_to-还是-has_one">2.7 使用 <code>belongs_to</code> 还是 <code>has_one</code>
</h4><p>如果想建立两个模型之间的一对一关系，可以在一个模型中声明 <code>belongs_to</code>，然后在另一模型中声明 <code>has_one</code>。但是怎么知道在哪个模型中声明哪种关联？</p><p>不同的声明方式带来的区别是外键放在哪个模型对应的数据表中（外键在声明 <code>belongs_to</code> 关联所在模型对应的数据表中）。不过声明时要考虑一下语义，<code>has_one</code> 的意思是某样东西属于我。例如，说供应商有一个账户，比账户拥有供应商更合理，所以正确的关联应该这么声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account
end

class Account &lt; ActiveRecord::Base
  belongs_to :supplier
end

</pre>
</div>
<p>相应的迁移如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateSuppliers &lt; ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end
end

</pre>
</div>
<div class="note"><p><code>t.integer :supplier_id</code> 更明确的表明了外键的名字。在目前的 Rails 版本中，可以抽象实现的细节，使用 <code>t.references :supplier</code> 代替。</p></div><h4 id="使用-has_many-:through-还是-has_and_belongs_to_many">2.8 使用 <code>has_many :through</code> 还是 <code>has_and_belongs_to_many</code>
</h4><p>Rails 提供了两种建立模型之间多对多关系的方法。其中比较简单的是 <code>has_and_belongs_to_many</code>，可以直接建立关联：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Assembly &lt; ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

</pre>
</div>
<p>第二种方法是使用 <code>has_many :through</code>，但无法直接建立关联，要通过第三个模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Assembly &lt; ActiveRecord::Base
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest &lt; ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end

class Part &lt; ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, through: :manifests
end

</pre>
</div>
<p>根据经验，如果关联的第三个模型要作为独立实体使用，要用 <code>has_many :through</code> 关联；如果不需要使用第三个模型，用简单的 <code>has_and_belongs_to_many</code> 关联即可（不过要记得在数据库中创建连接数据表）。</p><p>如果需要做数据验证、回调，或者连接模型上要用到其他属性，此时就要使用 <code>has_many :through</code> 关联。</p><h4 id="多态关联">2.9 多态关联</h4><p>关联还有一种高级用法，“多态关联”。在多态关联中，在同一个关联中，模型可以属于其他多个模型。例如，图片模型可以属于雇员模型或者产品模型，模型的定义如下：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Picture &lt; ActiveRecord::Base
  belongs_to :imageable, polymorphic: true
end

class Employee &lt; ActiveRecord::Base
  has_many :pictures, as: :imageable
end

class Product &lt; ActiveRecord::Base
  has_many :pictures, as: :imageable
end

</pre>
</div>
<p>在 <code>belongs_to</code> 中指定使用多态，可以理解成创建了一个接口，可供任何一个模型使用。在 <code>Employee</code> 模型实例上，可以使用 <code>@employee.pictures</code> 获取图片集合。类似地，可使用 <code>@product.pictures</code> 获取产品的图片。</p><p>在 <code>Picture</code> 模型的实例上，可以使用 <code>@picture.imageable</code> 获取父对象。不过事先要在声明多态接口的模型中创建外键字段和类型字段：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreatePictures &lt; ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end
end

</pre>
</div>
<p>上面的迁移可以使用 <code>t.references</code> 简化：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreatePictures &lt; ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end

</pre>
</div>
<p><img src="images/polymorphic.png" alt="多态关联"></p><h4 id="自连接">2.10 自连接</h4><p>设计数据模型时会发现，有时模型要和自己建立关联。例如，在一个数据表中保存所有雇员的信息，但要建立经理和下属之间的关系。这种情况可以使用自连接关联解决：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Employee &lt; ActiveRecord::Base
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"

  belongs_to :manager, class_name: "Employee"
end

</pre>
</div>
<p>这样定义模型后，就可以使用 <code>@employee.subordinates</code> 和 <code>@employee.manager</code> 了。</p><p>在迁移中，要添加一个引用字段，指向模型自身：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateEmployees &lt; ActiveRecord::Migration
  def change
    create_table :employees do |t|
      t.references :manager
      t.timestamps
    end
  end
end

</pre>
</div>
<h3 id="小技巧和注意事项">3 小技巧和注意事项</h3><p>在 Rails 程序中高效地使用 Active Record 关联，要了解以下几个知识：</p>
<ul>
<li>缓存控制</li>
<li>避免命名冲突</li>
<li>更新模式</li>
<li>控制关联的作用域</li>
<li>Bi-directional associations</li>
</ul>
<h4 id="缓存控制">3.1 缓存控制</h4><p>关联添加的方法都会使用缓存，记录最近一次查询结果，以备后用。缓存还会在方法之间共享。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
customer.orders                 # retrieves orders from the database
customer.orders.size            # uses the cached copy of orders
customer.orders.empty?          # uses the cached copy of orders

</pre>
</div>
<p>程序的其他部分会修改数据，那么应该怎么重载缓存呢？调用关联方法时传入 <code>true</code> 参数即可：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
customer.orders                 # retrieves orders from the database
customer.orders.size            # uses the cached copy of orders
customer.orders(true).empty?    # discards the cached copy of orders
                                # and goes back to the database

</pre>
</div>
<h4 id="避免命名冲突">3.2 避免命名冲突</h4><p>关联的名字并不能随意使用。因为创建关联时，会向模型添加同名方法，所以关联的名字不能和 <code>ActiveRecord::Base</code> 中的实例方法同名。如果同名，关联方法会覆盖 <code>ActiveRecord::Base</code> 中的实例方法，导致错误。例如，关联的名字不能为 <code>attributes</code> 或 <code>connection</code>。</p><h4 id="更新模式">3.3 更新模式</h4><p>关联非常有用，但没什么魔法。关联对应的数据库模式需要你自己编写。不同的关联类型，要做的事也不同。对 <code>belongs_to</code> 关联来说，要创建外键；对 <code>has_and_belongs_to_many</code> 来说，要创建相应的连接数据表。</p><h5 id="创建-belongs_to-关联所需的外键">3.3.1 创建 <code>belongs_to</code> 关联所需的外键</h5><p>声明 <code>belongs_to</code> 关联后，要创建相应的外键。例如，有下面这个模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer
end

</pre>
</div>
<p>这种关联需要在数据表中创建合适的外键：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateOrders &lt; ActiveRecord::Migration
  def change
    create_table :orders do |t|
      t.datetime :order_date
      t.string   :order_number
      t.integer  :customer_id
    end
  end
end

</pre>
</div>
<p>如果声明关联之前已经定义了模型，则要在迁移中使用 <code>add_column</code> 创建外键。</p><h5 id="创建-has_and_belongs_to_many-关联所需的连接数据表">3.3.2 创建 <code>has_and_belongs_to_many</code> 关联所需的连接数据表</h5><p>声明 <code>has_and_belongs_to_many</code> 关联后，必须手动创建连接数据表。除非在 <code>:join_table</code> 选项中指定了连接数据表的名字，否则 Active Record 会按照类名出现在字典中的顺序为数据表起名字。那么，顾客和订单模型使用的连接数据表默认名为“customers_orders”，因为在字典中，“c”在“o”前面。</p><div class="warning"><p>模型名的顺序使用字符串的 <code>&lt;</code> 操作符确定。所以，如果两个字符串的长度不同，比较最短长度时，两个字符串是相等的，但长字符串的排序比短字符串靠前。例如，你可能以为“"paper_boxes”和“papers”这两个表生成的连接表名为“papers_paper_boxes”，因为“paper_boxes”比“papers”长。其实生成的连接表名为“paper_boxes_papers”，因为在一般的编码方式中，“_”比“s”靠前。</p></div><p>不管名字是什么，你都要在迁移中手动创建连接数据表。例如下面的关联声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Assembly &lt; ActiveRecord::Base
  has_and_belongs_to_many :parts
end

class Part &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

</pre>
</div>
<p>需要在迁移中创建 <code>assemblies_parts</code> 数据表，而且该表无主键：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateAssembliesPartsJoinTable &lt; ActiveRecord::Migration
  def change
    create_table :assemblies_parts, id: false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end
end

</pre>
</div>
<p>我们把 <code>id: false</code> 选项传给 <code>create_table</code> 方法，因为这个表不对应模型。只有这样，关联才能正常建立。如果在使用 <code>has_and_belongs_to_many</code> 关联时遇到奇怪的表现，例如提示模型 ID 损坏，或 ID 冲突，有可能就是因为创建了主键。</p><h4 id="控制关联的作用域">3.4 控制关联的作用域</h4><p>默认情况下，关联只会查找当前模块作用域中的对象。如果在模块中定义 Active Record 模型，知道这一点很重要。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module MyApplication
  module Business
    class Supplier &lt; ActiveRecord::Base
       has_one :account
    end

    class Account &lt; ActiveRecord::Base
       belongs_to :supplier
    end
  end
end

</pre>
</div>
<p>上面的代码能正常运行，因为 <code>Supplier</code> 和 <code>Account</code> 在同一个作用域内。但下面这段代码就不行了，因为 <code>Supplier</code> 和 <code>Account</code> 在不同的作用域中：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module MyApplication
  module Business
    class Supplier &lt; ActiveRecord::Base
       has_one :account
    end
  end

  module Billing
    class Account &lt; ActiveRecord::Base
       belongs_to :supplier
    end
  end
end

</pre>
</div>
<p>要想让处在不同命名空间中的模型正常建立关联，声明关联时要指定完整的类名：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module MyApplication
  module Business
    class Supplier &lt; ActiveRecord::Base
       has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account &lt; ActiveRecord::Base
       belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end

</pre>
</div>
<h4 id="双向关联">3.5 双向关联</h4><p>一般情况下，都要求能在关联的两端进行操作。例如，有下面的关联声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
end

</pre>
</div>
<p>默认情况下，Active Record 并不知道这个关联中两个模型之间的联系。可能导致同一对象的两个副本不同步：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # =&gt; true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # =&gt; false

</pre>
</div>
<p>之所以会发生这种情况，是因为 <code>c</code> 和 <code>o.customer</code> 在内存中是同一数据的两种表示，修改其中一个并不会刷新另一个。Active Record 提供了 <code>:inverse_of</code> 选项，可以告知 Rails 两者之间的关系：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, inverse_of: :customer
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer, inverse_of: :orders
end

</pre>
</div>
<p>这么修改之后，Active Record 就只会加载一个顾客对象，避免数据的不一致性，提高程序的执行效率：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # =&gt; true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # =&gt; true

</pre>
</div>
<p><code>inverse_of</code> 有些限制：</p>
<ul>
<li>不能和 <code>:through</code> 选项同时使用；</li>
<li>不能和 <code>:polymorphic</code> 选项同时使用；</li>
<li>不能和 <code>:as</code> 选项同时使用；</li>
<li>在 <code>belongs_to</code> 关联中，会忽略 <code>has_many</code> 关联的 <code>inverse_of</code> 选项；</li>
</ul>
<p>每种关联都会尝试自动找到关联的另一端，设置 <code>:inverse_of</code> 选项（根据关联的名字）。使用标准名字的关联都有这种功能。但是，如果在关联中设置了下面这些选项，将无法自动设置 <code>:inverse_of</code>：</p>
<ul>
<li><code>:conditions</code></li>
<li><code>:through</code></li>
<li><code>:polymorphic</code></li>
<li><code>:foreign_key</code></li>
</ul>
<h3 id="关联详解">4 关联详解</h3><p>下面几节详细说明各种关联，包括添加的方法和声明关联时可以使用的选项。</p><h4 id="belongs_to-关联详解">4.1 <code>belongs_to</code> 关联详解</h4><p><code>belongs_to</code> 关联创建一个模型与另一个模型之间的一对一关系。用数据库的行话来说，就是这个类中包含了外键。如果外键在另一个类中，就应该使用 <code>has_one</code> 关联。</p><h5 id="belongs_to-关联添加的方法">4.1.1 <code>belongs_to</code> 关联添加的方法</h5><p>声明  <code>belongs_to</code> 关联后，所在的类自动获得了五个和关联相关的方法：</p>
<ul>
<li><code>association(force_reload = false)</code></li>
<li><code>association=(associate)</code></li>
<li><code>build_association(attributes = {})</code></li>
<li><code>create_association(attributes = {})</code></li>
<li><code>create_association!(attributes = {})</code></li>
</ul>
<p>这五个方法中的 <code>association</code> 要替换成传入 <code>belongs_to</code> 方法的第一个参数。例如，如下的声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer
end

</pre>
</div>
<p>每个 <code>Order</code> 模型实例都获得了这些方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
customer
customer=
build_customer
create_customer
create_customer!

</pre>
</div>
<div class="note"><p>在 <code>has_one</code> 和 <code>belongs_to</code> 关联中，必须使用 <code>build_*</code> 方法构建关联对象。<code>association.build</code> 方法是在 <code>has_many</code> 和 <code>has_and_belongs_to_many</code> 关联中使用的。创建关联对象要使用 <code>create_*</code> 方法。</p></div><h6 id="belongs_to-关联添加的方法-association(force_reload-=-false)">4.1.1.1 <code>association(force_reload = false)</code>
</h6><p>如果关联的对象存在，<code>association</code> 方法会返回关联对象。如果找不到关联对象，则返回 <code>nil</code>。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer = @order.customer

</pre>
</div>
<p>如果关联对象之前已经取回，会返回缓存版本。如果不想使用缓存版本，强制重新从数据库中读取，可以把 <code>force_reload</code> 参数设为 <code>true</code>。</p><h6 id="belongs_to-关联添加的方法-association=(associate)">4.1.1.2 <code>association=(associate)</code>
</h6><p><code>association=</code> 方法用来赋值关联的对象。这个方法的底层操作是，从关联对象上读取主键，然后把值赋给该主键对应的对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order.customer = @customer

</pre>
</div>
<h6 id="belongs_to-关联添加的方法-build_association(attributes-=-{})">4.1.1.3 <code>build_association(attributes = {})</code>
</h6><p><code>build_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，但关联对象不会存入数据库。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer = @order.build_customer(customer_number: 123,
                                  customer_name: "John Doe")

</pre>
</div>
<h6 id="belongs_to-关联添加的方法-create_association(attributes-=-{})">4.1.1.4 <code>create_association(attributes = {})</code>
</h6><p><code>create_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，只要能通过所有数据验证，就会把关联对象存入数据库。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer = @order.create_customer(customer_number: 123,
                                   customer_name: "John Doe")

</pre>
</div>
<h6 id="belongs_to-关联添加的方法-create_association-bang(attributes-=-{})">4.1.1.5 <code>create_association!(attributes = {})</code>
</h6><p>和 <code>create_association</code> 方法作用相同，但是如果记录不合法，会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p><h5 id="belongs_to-方法的选项">4.1.2 <code>belongs_to</code> 方法的选项</h5><p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>belongs_to</code> 关联的行为。定制的方法很简单，声明关联时传入选项或者使用代码块即可。例如，下面的关联使用了两个选项：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, dependent: :destroy,
    counter_cache: true
end

</pre>
</div>
<p><code>belongs_to</code> 关联支持以下选项：</p>
<ul>
<li><code>:autosave</code></li>
<li><code>:class_name</code></li>
<li><code>:counter_cache</code></li>
<li><code>:dependent</code></li>
<li><code>:foreign_key</code></li>
<li><code>:inverse_of</code></li>
<li><code>:polymorphic</code></li>
<li><code>:touch</code></li>
<li><code>:validate</code></li>
</ul>
<h6 id="belongs_to-方法的选项-:autosave">4.1.2.1 <code>:autosave</code>
</h6><p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p><h6 id="belongs_to-方法的选项-:class_name">4.1.2.2 <code>:class_name</code>
</h6><p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，如果订单属于顾客，但表示顾客的模型是 <code>Patron</code>，就可以这样声明关联：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, class_name: "Patron"
end

</pre>
</div>
<h6 id=":counter_cache">4.1.2.3 <code>:counter_cache</code>
</h6><p><code>:counter_cache</code> 选项可以提高统计所属对象数量操作的效率。假如如下的模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer
end
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<p>这样声明关联后，如果想知道 <code>@customer.orders.size</code> 的结果，就要在数据库中执行 <code>COUNT(*)</code> 查询。如果不想执行这个查询，可以在声明 <code>belongs_to</code> 关联的模型中加入计数缓存功能：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, counter_cache: true
end
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<p>这样声明关联后，Rails 会及时更新缓存，调用 <code>size</code> 方法时返回缓存中的值。</p><p>虽然 <code>:counter_cache</code> 选项在声明 <code>belongs_to</code> 关联的模型中设置，但实际使用的字段要添加到关联的模型中。针对上面的例子，要把 <code>orders_count</code> 字段加入 <code>Customer</code> 模型。这个字段的默认名也是可以设置的：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, counter_cache: :count_of_orders
end
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<p>计数缓存字段通过 <code>attr_readonly</code> 方法加入关联模型的只读属性列表中。</p><h6 id="belongs_to-方法的选项-:dependent">4.1.2.4 <code>:dependent</code>
</h6><p><code>:dependent</code> 选项的值有两个：</p>
<ul>
<li>
<code>:destroy</code>：销毁对象时，也会在关联对象上调用 <code>destroy</code> 方法；</li>
<li>
<code>:delete</code>：销毁对象时，关联的对象不会调用 <code>destroy</code> 方法，而是直接从数据库中删除；</li>
</ul>
<div class="warning"><p>在 <code>belongs_to</code> 关联和 <code>has_many</code> 关联配对时，不应该设置这个选项，否则会导致数据库中出现孤儿记录。</p></div><h6 id="belongs_to-方法的选项-:foreign_key">4.1.2.5 <code>:foreign_key</code>
</h6><p>按照约定，用来存储外键的字段名是关联名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, class_name: "Patron",
                        foreign_key: "patron_id"
end

</pre>
</div>
<div class="info"><p>不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。</p></div><h6 id="belongs_to-方法的选项-:inverse_of">4.1.2.6 <code>:inverse_of</code>
</h6><p><code>:inverse_of</code> 选项指定 <code>belongs_to</code> 关联另一端的 <code>has_many</code> 和 <code>has_one</code> 关联名。不能和 <code>:polymorphic</code> 选项一起使用。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, inverse_of: :customer
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer, inverse_of: :orders
end

</pre>
</div>
<h6 id=":polymorphic">4.1.2.7 <code>:polymorphic</code>
</h6><p><code>:polymorphic</code> 选项为 <code>true</code> 时表明这是个多态关联。<a href="#polymorphic-associations">前文</a>已经详细介绍过多态关联。</p><h6 id=":touch">4.1.2.8 <code>:touch</code>
</h6><p>如果把 <code>:touch</code> 选项设为 <code>true</code>，保存或销毁对象时，关联对象的 <code>updated_at</code> 或 <code>updated_on</code> 字段会自动设为当前时间戳。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, touch: true
end

class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<p>在这个例子中，保存或销毁订单后，会更新关联的顾客中的时间戳。还可指定要更新哪个字段的时间戳：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, touch: :orders_updated_at
end

</pre>
</div>
<h6 id="belongs_to-方法的选项-:validate">4.1.2.9 <code>:validate</code>
</h6><p>如果把 <code>:validate</code> 选项设为 <code>true</code>，保存对象时，会同时验证关联对象。该选项的默认值是 <code>false</code>，保存对象时不验证关联对象。</p><h5 id="belongs_to-的作用域">4.1.3 <code>belongs_to</code> 的作用域</h5><p>有时可能需要定制 <code>belongs_to</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, -&gt; { where active: true },
                        dependent: :destroy
end

</pre>
</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>
<ul>
<li><code>where</code></li>
<li><code>includes</code></li>
<li><code>readonly</code></li>
<li><code>select</code></li>
</ul>
<h6 id="belongs_to-的作用域-where">4.1.3.1 <code>where</code>
</h6><p><code>where</code> 方法指定关联对象必须满足的条件。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :customer, -&gt; { where active: true }
end

</pre>
</div>
<h6 id="belongs_to-的作用域-includes">4.1.3.2 <code>includes</code>
</h6><p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class LineItem &lt; ActiveRecord::Base
  belongs_to :order
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end

class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<p>如果经常要直接从商品上获取顾客对象（<code>@line_item.order.customer</code>），就可以把顾客引入商品和订单的关联中：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class LineItem &lt; ActiveRecord::Base
  belongs_to :order, -&gt; { includes :customer }
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end

class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<div class="note"><p>直接关联没必要使用 <code>includes</code>。如果 <code>Order belongs_to :customer</code>，那么顾客会自动按需加载。</p></div><h6 id="belongs_to-的作用域-readonly">4.1.3.3 <code>readonly</code>
</h6><p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p><h6 id="belongs_to-的作用域-select">4.1.3.4 <code>select</code>
</h6><p><code>select</code> 方法会覆盖获取关联对象使用的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p><div class="info"><p>如果在 <code>belongs_to</code> 关联中使用 <code>select</code> 方法，应该同时设置 <code>:foreign_key</code> 选项，确保返回正确的结果。</p></div><h5 id="belongs_to-关联详解-检查关联的对象是否存在">4.1.4 检查关联的对象是否存在</h5><p>检查关联的对象是否存在可以使用 <code>association.nil?</code> 方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
if @order.customer.nil?
  @msg = "No customer found for this order"
end

</pre>
</div>
<h5 id="belongs_to-关联详解-什么时候保存对象">4.1.5 什么时候保存对象</h5><p>把对象赋值给 <code>belongs_to</code> 关联不会自动保存对象，也不会保存关联的对象。</p><h4 id="has_one-关联详解">4.2 <code>has_one</code> 关联详解</h4><p><code>has_one</code> 关联建立两个模型之间的一对一关系。用数据库的行话说，这种关联的意思是外键在另一个类中。如果外键在这个类中，应该使用 <code>belongs_to</code> 关联。</p><h5 id="has_one-关联添加的方法">4.2.1 <code>has_one</code> 关联添加的方法</h5><p>声明 <code>has_one</code> 关联后，声明所在的类自动获得了五个关联相关的方法：</p>
<ul>
<li><code>association(force_reload = false)</code></li>
<li><code>association=(associate)</code></li>
<li><code>build_association(attributes = {})</code></li>
<li><code>create_association(attributes = {})</code></li>
<li><code>create_association!(attributes = {})</code></li>
</ul>
<p>这五个方法中的 <code>association</code> 要替换成传入 <code>has_one</code> 方法的第一个参数。例如，如下的声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account
end

</pre>
</div>
<p>每个 <code>Supplier</code> 模型实例都获得了这些方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
account
account=
build_account
create_account
create_account!

</pre>
</div>
<div class="note"><p>在 <code>has_one</code> 和 <code>belongs_to</code> 关联中，必须使用 <code>build_*</code> 方法构建关联对象。<code>association.build</code> 方法是在 <code>has_many</code> 和 <code>has_and_belongs_to_many</code> 关联中使用的。创建关联对象要使用 <code>create_*</code> 方法。</p></div><h6 id="has_one-关联添加的方法-association(force_reload-=-false)">4.2.1.1 <code>association(force_reload = false)</code>
</h6><p>如果关联的对象存在，<code>association</code> 方法会返回关联对象。如果找不到关联对象，则返回 <code>nil</code>。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@account = @supplier.account

</pre>
</div>
<p>如果关联对象之前已经取回，会返回缓存版本。如果不想使用缓存版本，强制重新从数据库中读取，可以把 <code>force_reload</code> 参数设为 <code>true</code>。</p><h6 id="has_one-关联添加的方法-association=(associate)">4.2.1.2 <code>association=(associate)</code>
</h6><p><code>association=</code> 方法用来赋值关联的对象。这个方法的底层操作是，从关联对象上读取主键，然后把值赋给该主键对应的关联对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@supplier.account = @account

</pre>
</div>
<h6 id="has_one-关联添加的方法-build_association(attributes-=-{})">4.2.1.3 <code>build_association(attributes = {})</code>
</h6><p><code>build_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，但关联对象不会存入数据库。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@account = @supplier.build_account(terms: "Net 30")

</pre>
</div>
<h6 id="has_one-关联添加的方法-create_association(attributes-=-{})">4.2.1.4 <code>create_association(attributes = {})</code>
</h6><p><code>create_association</code> 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，只要能通过所有数据验证，就会把关联对象存入数据库。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@account = @supplier.create_account(terms: "Net 30")

</pre>
</div>
<h6 id="has_one-关联添加的方法-create_association-bang(attributes-=-{})">4.2.1.5 <code>create_association!(attributes = {})</code>
</h6><p>和 <code>create_association</code> 方法作用相同，但是如果记录不合法，会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p><h5 id="has_one-方法的选项">4.2.2 <code>has_one</code> 方法的选项</h5><p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>has_one</code> 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, class_name: "Billing", dependent: :nullify
end

</pre>
</div>
<p><code>has_one</code> 关联支持以下选项：</p>
<ul>
<li><code>:as</code></li>
<li><code>:autosave</code></li>
<li><code>:class_name</code></li>
<li><code>:dependent</code></li>
<li><code>:foreign_key</code></li>
<li><code>:inverse_of</code></li>
<li><code>:primary_key</code></li>
<li><code>:source</code></li>
<li><code>:source_type</code></li>
<li><code>:through</code></li>
<li><code>:validate</code></li>
</ul>
<h6 id="has_one-方法的选项-:as">4.2.2.1 <code>:as</code>
</h6><p><code>:as</code> 选项表明这是多态关联。<a href="#polymorphic-associations">前文</a>已经详细介绍过多态关联。</p><h6 id="has_one-方法的选项-:autosave">4.2.2.2 <code>:autosave</code>
</h6><p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p><h6 id="has_one-方法的选项-:class_name">4.2.2.3 <code>:class_name</code>
</h6><p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，供应商有一个账户，但表示账户的模型是 <code>Billing</code>，就可以这样声明关联：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, class_name: "Billing"
end

</pre>
</div>
<h6 id="has_one-方法的选项-:dependent">4.2.2.4 <code>:dependent</code>
</h6><p>设置销毁拥有者时要怎么处理关联对象：</p>
<ul>
<li>
<code>:destroy</code>：也销毁关联对象；</li>
<li>
<code>:delete</code>：直接把关联对象对数据库中删除，因此不会执行回调；</li>
<li>
<code>:nullify</code>：把外键设为 <code>NULL</code>，不会执行回调；</li>
<li>
<code>:restrict_with_exception</code>：有关联的对象时抛出异常；</li>
<li>
<code>:restrict_with_error</code>：有关联的对象时，向拥有者添加一个错误；</li>
</ul>
<p>如果在数据库层设置了 <code>NOT NULL</code> 约束，就不能使用 <code>:nullify</code> 选项。如果 <code>:dependent</code> 选项没有销毁关联，就无法修改关联对象，因为关联对象的外键设置为不接受 <code>NULL</code>。</p><h6 id="has_one-方法的选项-:foreign_key">4.2.2.5 <code>:foreign_key</code>
</h6><p>按照约定，在另一个模型中用来存储外键的字段名是模型名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, foreign_key: "supp_id"
end

</pre>
</div>
<div class="info"><p>不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。</p></div><h6 id="has_one-方法的选项-:inverse_of">4.2.2.6 <code>:inverse_of</code>
</h6><p><code>:inverse_of</code> 选项指定 <code>has_one</code> 关联另一端的 <code>belongs_to</code> 关联名。不能和 <code>:through</code> 或 <code>:as</code> 选项一起使用。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, inverse_of: :supplier
end

class Account &lt; ActiveRecord::Base
  belongs_to :supplier, inverse_of: :account
end

</pre>
</div>
<h6 id="has_one-方法的选项-:primary_key">4.2.2.7 <code>:primary_key</code>
</h6><p>按照约定，用来存储该模型主键的字段名 <code>id</code>。<code>:primary_key</code> 选项可以设置要使用的主键名。</p><h6 id="has_one-方法的选项-:source">4.2.2.8 <code>:source</code>
</h6><p><code>:source</code> 选项指定 <code>has_one :through</code> 关联的关联源名字。</p><h6 id="has_one-方法的选项-:source_type">4.2.2.9 <code>:source_type</code>
</h6><p><code>:source_type</code> 选项指定 <code>has_one :through</code> 关联中用来处理多态关联的关联源类型。</p><h6 id="has_one-方法的选项-:through">4.2.2.10 <code>:through</code>
</h6><p><code>:through</code> 选项指定用来执行查询的连接模型。<a href="#the-has-one-through-association">前文</a>详细介绍过 <code>has_one :through</code> 关联。</p><h6 id="has_one-方法的选项-:validate">4.2.2.11 <code>:validate</code>
</h6><p>如果把 <code>:validate</code> 选项设为 <code>true</code>，保存对象时，会同时验证关联对象。该选项的默认值是 <code>false</code>，保存对象时不验证关联对象。</p><h5 id="has_one-的作用域">4.2.3 <code>has_one</code> 的作用域</h5><p>有时可能需要定制 <code>has_one</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, -&gt; { where active: true }
end

</pre>
</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>
<ul>
<li><code>where</code></li>
<li><code>includes</code></li>
<li><code>readonly</code></li>
<li><code>select</code></li>
</ul>
<h6 id="has_one-的作用域-where">4.2.3.1 <code>where</code>
</h6><p><code>where</code> 方法指定关联对象必须满足的条件。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, -&gt; { where "confirmed = 1" }
end

</pre>
</div>
<h6 id="has_one-的作用域-includes">4.2.3.2 <code>includes</code>
</h6><p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account
end

class Account &lt; ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end

class Representative &lt; ActiveRecord::Base
  has_many :accounts
end

</pre>
</div>
<p>如果经常要直接获取供应商代表（<code>@supplier.account.representative</code>），就可以把代表引入供应商和账户的关联中：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Supplier &lt; ActiveRecord::Base
  has_one :account, -&gt; { includes :representative }
end

class Account &lt; ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end

class Representative &lt; ActiveRecord::Base
  has_many :accounts
end

</pre>
</div>
<h6 id="has_one-的作用域-readonly">4.2.3.3 <code>readonly</code>
</h6><p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p><h6 id="has_one-的作用域-select">4.2.3.4 <code>select</code>
</h6><p><code>select</code> 方法会覆盖获取关联对象使用的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p><h5 id="has_one-关联详解-检查关联的对象是否存在">4.2.4 检查关联的对象是否存在</h5><p>检查关联的对象是否存在可以使用 <code>association.nil?</code> 方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end

</pre>
</div>
<h5 id="has_one-关联详解-什么时候保存对象">4.2.5 什么时候保存对象</h5><p>把对象赋值给 <code>has_one</code> 关联时，会自动保存对象（因为要更新外键）。而且所有被替换的对象也会自动保存，因为外键也变了。</p><p>如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 <code>false</code>，赋值操作会取消。</p><p>如果父对象（<code>has_one</code> 关联声明所在的模型）没保存（<code>new_record?</code> 方法返回 <code>true</code>），那么子对象也不会保存。只有保存了父对象，才会保存子对象。</p><p>如果赋值给 <code>has_one</code> 关联时不想保存对象，可以使用 <code>association.build</code> 方法。</p><h4 id="has_many-关联详解">4.3 <code>has_many</code> 关联详解</h4><p><code>has_many</code> 关联建立两个模型之间的一对多关系。用数据库的行话说，这种关联的意思是外键在另一个类中，指向这个类的实例。</p><h5 id="has_many-关联添加的方法">4.3.1 <code>has_many</code> 关联添加的方法</h5><p>声明 <code>has_many</code> 关联后，声明所在的类自动获得了 16 个关联相关的方法：</p>
<ul>
<li><code>collection(force_reload = false)</code></li>
<li><code>collection&lt;&lt;(object, ...)</code></li>
<li><code>collection.delete(object, ...)</code></li>
<li><code>collection.destroy(object, ...)</code></li>
<li><code>collection=objects</code></li>
<li><code>collection_singular_ids</code></li>
<li><code>collection_singular_ids=ids</code></li>
<li><code>collection.clear</code></li>
<li><code>collection.empty?</code></li>
<li><code>collection.size</code></li>
<li><code>collection.find(...)</code></li>
<li><code>collection.where(...)</code></li>
<li><code>collection.exists?(...)</code></li>
<li><code>collection.build(attributes = {}, ...)</code></li>
<li><code>collection.create(attributes = {})</code></li>
<li><code>collection.create!(attributes = {})</code></li>
</ul>
<p>这些个方法中的 <code>collection</code> 要替换成传入 <code>has_many</code> 方法的第一个参数。<code>collection_singular</code> 要替换成第一个参数的单数形式。例如，如下的声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

</pre>
</div>
<p>每个 <code>Customer</code> 模型实例都获得了这些方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
orders(force_reload = false)
orders&lt;&lt;(object, ...)
orders.delete(object, ...)
orders.destroy(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.where(...)
orders.exists?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
orders.create!(attributes = {})

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection(force_reload-=-false)">4.3.1.1 <code>collection(force_reload = false)</code>
</h6><p><code>collection</code> 方法返回一个数组，包含所有关联的对象。如果没有关联的对象，则返回空数组。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@orders = @customer.orders

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection&lt;&lt;(object,-...)">4.3.1.2 <code>collection&lt;&lt;(object, ...)</code>
</h6><p><code>collection&lt;&lt;</code> 方法向关联对象数组中添加一个或多个对象，并把各所加对象的外键设为调用此方法的模型的主键。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer.orders &lt;&lt; @order1

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.delete(object,-...)">4.3.1.3 <code>collection.delete(object, ...)</code>
</h6><p><code>collection.delete</code> 方法从关联对象数组中删除一个或多个对象，并把删除的对象外键设为 <code>NULL</code>。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer.orders.delete(@order1)

</pre>
</div>
<div class="warning"><p>如果关联设置了 <code>dependent: :destroy</code>，还会销毁关联对象；如果关联设置了 <code>dependent: :delete_all</code>，还会删除关联对象。</p></div><h6 id="has_many-关联添加的方法-collection.destroy(object,-...)">4.3.1.4 <code>collection.destroy(object, ...)</code>
</h6><p><code>collection.destroy</code> 方法在关联对象上调用 <code>destroy</code> 方法，从关联对象数组中删除一个或多个对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@customer.orders.destroy(@order1)

</pre>
</div>
<div class="warning"><p>对象会从数据库中删除，忽略 <code>:dependent</code> 选项。</p></div><h6 id="has_many-关联添加的方法-collection=objects">4.3.1.5 <code>collection=objects</code>
</h6><p><code>collection=</code> 让关联对象数组只包含指定的对象，根据需求会添加或删除对象。</p><h6 id="has_many-关联添加的方法-collection_singular_ids">4.3.1.6 <code>collection_singular_ids</code>
</h6><p><code>collection_singular_ids</code> 返回一个数组，包含关联对象数组中各对象的 ID。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order_ids = @customer.order_ids

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection_singular_ids=ids">4.3.1.7 <code>collection_singular_ids=ids</code>
</h6><p><code>collection_singular_ids=</code> 方法让数组中只包含指定的主键，根据需要增删 ID。</p><h6 id="has_many-关联添加的方法-collection.clear">4.3.1.8 <code>collection.clear</code>
</h6><p><code>collection.clear</code> 方法删除数组中的所有对象。如果关联中指定了 <code>dependent: :destroy</code> 选项，会销毁关联对象；如果关联中指定了 <code>dependent: :delete_all</code> 选项，会直接从数据库中删除对象，然后再把外键设为 <code>NULL</code>。</p><h6 id="has_many-关联添加的方法-collection.empty-questionmark">4.3.1.9 <code>collection.empty?</code>
</h6><p>如果关联数组中没有关联对象，<code>collection.empty?</code> 方法返回 <code>true</code>。</p><div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;% if @customer.orders.empty? %&gt;
  No Orders Found
&lt;% end %&gt;

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.size">4.3.1.10 <code>collection.size</code>
</h6><p><code>collection.size</code> 返回关联对象数组中的对象数量。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order_count = @customer.orders.size

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.find(...)">4.3.1.11 <code>collection.find(...)</code>
</h6><p><code>collection.find</code> 方法在关联对象数组中查找对象，句法和可用选项跟 <code>ActiveRecord::Base.find</code> 方法一样。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@open_orders = @customer.orders.find(1)

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.where(...)">4.3.1.12 <code>collection.where(...)</code>
</h6><p><code>collection.where</code> 方法根据指定的条件在关联对象数组中查找对象，但会惰性加载对象，用到对象时才会执行查询。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@open_orders = @customer.orders.where(open: true) # No query yet
@open_order = @open_orders.first # Now the database will be queried

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.exists-questionmark(...)">4.3.1.13 <code>collection.exists?(...)</code>
</h6><p><code>collection.exists?</code> 方法根据指定的条件检查关联对象数组中是否有符合条件的对象，句法和可用选项跟 <code>ActiveRecord::Base.exists?</code> 方法一样。</p><h6 id="collection.build(attributes-=-{},-...)">4.3.1.14 <code>collection.build(attributes = {}, ...)</code>
</h6><p><code>collection.build</code> 方法返回一个或多个此种关联类型的新对象。这些对象会使用传入的属性初始化，还会创建对应的外键，但不会保存关联对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order = @customer.orders.build(order_date: Time.now,
                                order_number: "A12345")

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.create(attributes-=-{})">4.3.1.15 <code>collection.create(attributes = {})</code>
</h6><p><code>collection.create</code> 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会创建对应的外键，只要能通过所有数据验证，就会保存关联对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@order = @customer.orders.create(order_date: Time.now,
                                 order_number: "A12345")

</pre>
</div>
<h6 id="has_many-关联添加的方法-collection.create-bang(attributes-=-{})">4.3.1.16 <code>collection.create!(attributes = {})</code>
</h6><p>作用和 <code>collection.create</code> 相同，但如果记录不合法会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p><h5 id="has_many-方法的选项">4.3.2 <code>has_many</code> 方法的选项</h5><p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>has_many</code> 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, dependent: :delete_all, validate: :false
end

</pre>
</div>
<p><code>has_many</code> 关联支持以下选项：</p>
<ul>
<li><code>:as</code></li>
<li><code>:autosave</code></li>
<li><code>:class_name</code></li>
<li><code>:dependent</code></li>
<li><code>:foreign_key</code></li>
<li><code>:inverse_of</code></li>
<li><code>:primary_key</code></li>
<li><code>:source</code></li>
<li><code>:source_type</code></li>
<li><code>:through</code></li>
<li><code>:validate</code></li>
</ul>
<h6 id="has_many-方法的选项-:as">4.3.2.1 <code>:as</code>
</h6><p><code>:as</code> 选项表明这是多态关联。<a href="#polymorphic-associations">前文</a>已经详细介绍过多态关联。</p><h6 id="has_many-方法的选项-:autosave">4.3.2.2 <code>:autosave</code>
</h6><p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p><h6 id="has_many-方法的选项-:class_name">4.3.2.3 <code>:class_name</code>
</h6><p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，顾客有多个订单，但表示订单的模型是 <code>Transaction</code>，就可以这样声明关联：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, class_name: "Transaction"
end

</pre>
</div>
<h6 id=":dependent">4.3.2.4 <code>:dependent</code>
</h6><p>设置销毁拥有者时要怎么处理关联对象：</p>
<ul>
<li>
<code>:destroy</code>：也销毁所有关联的对象；</li>
<li>
<code>:delete_all</code>：直接把所有关联对象对数据库中删除，因此不会执行回调；</li>
<li>
<code>:nullify</code>：把外键设为 <code>NULL</code>，不会执行回调；</li>
<li>
<code>:restrict_with_exception</code>：有关联的对象时抛出异常；</li>
<li>
<code>:restrict_with_error</code>：有关联的对象时，向拥有者添加一个错误；</li>
</ul>
<div class="note"><p>如果声明关联时指定了 <code>:through</code> 选项，会忽略这个选项。</p></div><h6 id="has_many-方法的选项-:foreign_key">4.3.2.5 <code>:foreign_key</code>
</h6><p>按照约定，另一个模型中用来存储外键的字段名是模型名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, foreign_key: "cust_id"
end

</pre>
</div>
<div class="info"><p>不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。</p></div><h6 id=":inverse_of">4.3.2.6 <code>:inverse_of</code>
</h6><p><code>:inverse_of</code> 选项指定 <code>has_many</code> 关联另一端的 <code>belongs_to</code> 关联名。不能和 <code>:through</code> 或 <code>:as</code> 选项一起使用。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, inverse_of: :customer
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer, inverse_of: :orders
end

</pre>
</div>
<h6 id="has_many-方法的选项-:primary_key">4.3.2.7 <code>:primary_key</code>
</h6><p>按照约定，用来存储该模型主键的字段名 <code>id</code>。<code>:primary_key</code> 选项可以设置要使用的主键名。</p><p>假设 <code>users</code> 表的主键是 <code>id</code>，但还有一个 <code>guid</code> 字段。根据要求，<code>todos</code> 表中应该使用 <code>guid</code> 字段，而不是 <code>id</code> 字段。这种需求可以这么实现：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  has_many :todos, primary_key: :guid
end

</pre>
</div>
<p>如果执行 <code>@user.todos.create</code> 创建新的待办事项，那么 <code>@todo.user_id</code> 就是 <code>guid</code> 字段中的值。</p><h6 id="has_many-方法的选项-:source">4.3.2.8 <code>:source</code>
</h6><p><code>:source</code> 选项指定 <code>has_many :through</code> 关联的关联源名字。只有无法从关联名种解出关联源的名字时才需要设置这个选项。</p><h6 id="has_many-方法的选项-:source_type">4.3.2.9 <code>:source_type</code>
</h6><p><code>:source_type</code> 选项指定 <code>has_many :through</code> 关联中用来处理多态关联的关联源类型。</p><h6 id="has_many-方法的选项-:through">4.3.2.10 <code>:through</code>
</h6><p><code>:through</code> 选项指定用来执行查询的连接模型。<code>has_many :through</code> 关联是实现多对多关联的一种方式，<a href="#the-has-many-through-association">前文</a>已经介绍过。</p><h6 id="has_many-方法的选项-:validate">4.3.2.11 <code>:validate</code>
</h6><p>如果把 <code>:validate</code> 选项设为 <code>false</code>，保存对象时，不会验证关联对象。该选项的默认值是 <code>true</code>，保存对象验证关联的对象。</p><h5 id="has_many-的作用域">4.3.3 <code>has_many</code> 的作用域</h5><p>有时可能需要定制 <code>has_many</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, -&gt; { where processed: true }
end

</pre>
</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>
<ul>
<li><code>where</code></li>
<li><code>extending</code></li>
<li><code>group</code></li>
<li><code>includes</code></li>
<li><code>limit</code></li>
<li><code>offset</code></li>
<li><code>order</code></li>
<li><code>readonly</code></li>
<li><code>select</code></li>
<li><code>uniq</code></li>
</ul>
<h6 id="has_many-的作用域-where">4.3.3.1 <code>where</code>
</h6><p><code>where</code> 方法指定关联对象必须满足的条件。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :confirmed_orders, -&gt; { where "confirmed = 1" },
    class_name: "Order"
end

</pre>
</div>
<p>条件还可以使用 Hash 的形式指定：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :confirmed_orders, -&gt; { where confirmed: true },
                              class_name: "Order"
end

</pre>
</div>
<p>如果 <code>where</code> 使用 Hash 形式，通过这个关联创建的记录会自动使用 Hash 中的作用域。针对上面的例子，使用 <code>@customer.confirmed_orders.create</code> 或 <code>@customer.confirmed_orders.build</code> 创建订单时，会自动把 <code>confirmed</code> 字段的值设为 <code>true</code>。</p><h6 id="has_many-的作用域-extending">4.3.3.2 <code>extending</code>
</h6><p><code>extending</code> 方法指定一个模块名，用来扩展关联代理。<a href="#association-extensions">后文</a>会详细介绍关联扩展。</p><h6 id="has_many-的作用域-group">4.3.3.3 <code>group</code>
</h6><p><code>group</code> 方法指定一个属性名，用在 SQL <code>GROUP BY</code> 子句中，分组查询结果。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :line_items, -&gt; { group 'orders.id' },
                        through: :orders
end

</pre>
</div>
<h6 id="has_many-的作用域-includes">4.3.3.4 <code>includes</code>
</h6><p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end

class LineItem &lt; ActiveRecord::Base
  belongs_to :order
end

</pre>
</div>
<p>如果经常要直接获取顾客购买的商品（<code>@customer.orders.line_items</code>），就可以把商品引入顾客和订单的关联中：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, -&gt; { includes :line_items }
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end

class LineItem &lt; ActiveRecord::Base
  belongs_to :order
end

</pre>
</div>
<h6 id="has_many-的作用域-limit">4.3.3.5 <code>limit</code>
</h6><p><code>limit</code> 方法限制通过关联获取的对象数量。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :recent_orders,
    -&gt; { order('order_date desc').limit(100) },
    class_name: "Order",
end

</pre>
</div>
<h6 id="has_many-的作用域-offset">4.3.3.6 <code>offset</code>
</h6><p><code>offset</code> 方法指定通过关联获取对象时的偏移量。例如，<code>-&gt; { offset(11) }</code> 会跳过前 11 个记录。</p><h6 id="has_many-的作用域-order">4.3.3.7 <code>order</code>
</h6><p><code>order</code> 方法指定获取关联对象时使用的排序方式，用于 SQL <code>ORDER BY</code> 子句。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, -&gt; { order "date_confirmed DESC" }
end

</pre>
</div>
<h6 id="has_many-的作用域-readonly">4.3.3.8 <code>readonly</code>
</h6><p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p><h6 id="has_many-的作用域-select">4.3.3.9 <code>select</code>
</h6><p><code>select</code> 方法用来覆盖获取关联对象数据的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p><div class="warning"><p>如果设置了 <code>select</code>，记得要包含主键和关联模型的外键。否则，Rails 会抛出异常。</p></div><h6 id="distinct">4.3.3.10 <code>distinct</code>
</h6><p>使用 <code>distinct</code> 方法可以确保集合中没有重复的对象，和 <code>:through</code> 选项一起使用最有用。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  has_many :readings
  has_many :posts, through: :readings
end

person = Person.create(name: 'John')
post   = Post.create(name: 'a1')
person.posts &lt;&lt; post
person.posts &lt;&lt; post
person.posts.inspect # =&gt; [#&lt;Post id: 5, name: "a1"&gt;, #&lt;Post id: 5, name: "a1"&gt;]
Reading.all.inspect  # =&gt; [#&lt;Reading id: 12, person_id: 5, post_id: 5&gt;, #&lt;Reading id: 13, person_id: 5, post_id: 5&gt;]

</pre>
</div>
<p>在上面的代码中，读者读了两篇文章，即使是同一篇文章，<code>person.posts</code> 也会返回两个对象。</p><p>下面我们加入 <code>distinct</code> 方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person
  has_many :readings
  has_many :posts, -&gt; { distinct }, through: :readings
end

person = Person.create(name: 'Honda')
post   = Post.create(name: 'a1')
person.posts &lt;&lt; post
person.posts &lt;&lt; post
person.posts.inspect # =&gt; [#&lt;Post id: 7, name: "a1"&gt;]
Reading.all.inspect  # =&gt; [#&lt;Reading id: 16, person_id: 7, post_id: 7&gt;, #&lt;Reading id: 17, person_id: 7, post_id: 7&gt;]

</pre>
</div>
<p>在这段代码中，读者还是读了两篇文章，但 <code>person.posts</code> 只返回一个对象，因为加载的集合已经去除了重复元素。</p><p>如果要确保只把不重复的记录写入关联模型的数据表（这样就不会从数据库中获取重复记录了），需要在数据表上添加唯一性索引。例如，数据表名为 <code>person_posts</code>，我们要保证其中所有的文章都没重复，可以在迁移中加入以下代码：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
add_index :person_posts, :post, unique: true

</pre>
</div>
<p>注意，使用 <code>include?</code> 等方法检查唯一性可能导致条件竞争。不要使用 <code>include?</code> 确保关联的唯一性。还是以前面的文章模型为例，下面的代码会导致条件竞争，因为多个用户可能会同时执行这一操作：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
person.posts &lt;&lt; post unless person.posts.include?(post)

</pre>
</div>
<h5 id="has_many-关联详解-什么时候保存对象">4.3.4 什么时候保存对象</h5><p>把对象赋值给 <code>has_many</code> 关联时，会自动保存对象（因为要更新外键）。如果一次赋值多个对象，所有对象都会自动保存。</p><p>如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 <code>false</code>，赋值操作会取消。</p><p>如果父对象（<code>has_many</code> 关联声明所在的模型）没保存（<code>new_record?</code> 方法返回 <code>true</code>），那么子对象也不会保存。只有保存了父对象，才会保存子对象。</p><p>如果赋值给 <code>has_many</code> 关联时不想保存对象，可以使用 <code>collection.build</code> 方法。</p><h4 id="has_and_belongs_to_many-关联详解">4.4 <code>has_and_belongs_to_many</code> 关联详解</h4><p><code>has_and_belongs_to_many</code> 关联建立两个模型之间的多对多关系。用数据库的行话说，这种关联的意思是有个连接数据表包含指向这两个类的外键。</p><h5 id="has_and_belongs_to_many-关联添加的方法">4.4.1 <code>has_and_belongs_to_many</code> 关联添加的方法</h5><p>声明 <code>has_and_belongs_to_many</code> 关联后，声明所在的类自动获得了 16 个关联相关的方法：</p>
<ul>
<li><code>collection(force_reload = false)</code></li>
<li><code>collection&lt;&lt;(object, ...)</code></li>
<li><code>collection.delete(object, ...)</code></li>
<li><code>collection.destroy(object, ...)</code></li>
<li><code>collection=objects</code></li>
<li><code>collection_singular_ids</code></li>
<li><code>collection_singular_ids=ids</code></li>
<li><code>collection.clear</code></li>
<li><code>collection.empty?</code></li>
<li><code>collection.size</code></li>
<li><code>collection.find(...)</code></li>
<li><code>collection.where(...)</code></li>
<li><code>collection.exists?(...)</code></li>
<li><code>collection.build(attributes = {})</code></li>
<li><code>collection.create(attributes = {})</code></li>
<li><code>collection.create!(attributes = {})</code></li>
</ul>
<p>这些个方法中的 <code>collection</code> 要替换成传入 <code>has_and_belongs_to_many</code> 方法的第一个参数。<code>collection_singular</code> 要替换成第一个参数的单数形式。例如，如下的声明：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Part &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

</pre>
</div>
<p>每个 <code>Part</code> 模型实例都获得了这些方法：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
assemblies(force_reload = false)
assemblies&lt;&lt;(object, ...)
assemblies.delete(object, ...)
assemblies.destroy(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.where(...)
assemblies.exists?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
assemblies.create!(attributes = {})

</pre>
</div>
<h6 id="额外的字段方法">4.4.1.1 额外的字段方法</h6><p>如果 <code>has_and_belongs_to_many</code> 关联使用的连接数据表中，除了两个外键之外还有其他字段，通过关联获取的记录中会包含这些字段，但是只读字段，因为 Rails 不知道如何保存对这些字段的改动。</p><div class="warning"><p>在 <code>has_and_belongs_to_many</code> 关联的连接数据表中使用其他字段的功能已经废弃。如果在多对多关联中需要使用这么复杂的数据表，可以用 <code>has_many :through</code> 关联代替 <code>has_and_belongs_to_many</code> 关联。</p></div><h6 id="has_and_belongs_to_many-关联添加的方法-collection(force_reload-=-false)">4.4.1.2 <code>collection(force_reload = false)</code>
</h6><p><code>collection</code> 方法返回一个数组，包含所有关联的对象。如果没有关联的对象，则返回空数组。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@assemblies = @part.assemblies

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection&lt;&lt;(object,-...)">4.4.1.3 <code>collection&lt;&lt;(object, ...)</code>
</h6><p><code>collection&lt;&lt;</code> 方法向关联对象数组中添加一个或多个对象，并在连接数据表中创建相应的记录。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@part.assemblies &lt;&lt; @assembly1

</pre>
</div>
<div class="note"><p>这个方法与 <code>collection.concat</code> 和 <code>collection.push</code> 是同名方法。</p></div><h6 id="has_and_belongs_to_many-关联添加的方法-collection.delete(object,-...)">4.4.1.4 <code>collection.delete(object, ...)</code>
</h6><p><code>collection.delete</code> 方法从关联对象数组中删除一个或多个对象，并删除连接数据表中相应的记录。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@part.assemblies.delete(@assembly1)

</pre>
</div>
<div class="warning"><p>这个方法不会触发连接记录上的回调。</p></div><h6 id="has_and_belongs_to_many-关联添加的方法-collection.destroy(object,-...)">4.4.1.5 <code>collection.destroy(object, ...)</code>
</h6><p><code>collection.destroy</code> 方法在连接数据表中的记录上调用 <code>destroy</code> 方法，从关联对象数组中删除一个或多个对象，还会触发回调。这个方法不会销毁对象本身。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@part.assemblies.destroy(@assembly1)

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection=objects">4.4.1.6 <code>collection=objects</code>
</h6><p><code>collection=</code> 让关联对象数组只包含指定的对象，根据需求会添加或删除对象。</p><h6 id="has_and_belongs_to_many-关联添加的方法-collection_singular_ids">4.4.1.7 <code>collection_singular_ids</code>
</h6><p><code>collection_singular_ids</code> 返回一个数组，包含关联对象数组中各对象的 ID。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@assembly_ids = @part.assembly_ids

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection_singular_ids=ids">4.4.1.8 <code>collection_singular_ids=ids</code>
</h6><p><code>collection_singular_ids=</code> 方法让数组中只包含指定的主键，根据需要增删 ID。</p><h6 id="has_and_belongs_to_many-关联添加的方法-collection.clear">4.4.1.9 <code>collection.clear</code>
</h6><p><code>collection.clear</code> 方法删除数组中的所有对象，并把连接数据表中的相应记录删除。这个方法不会销毁关联对象。</p><h6 id="has_and_belongs_to_many-关联添加的方法-collection.empty-questionmark">4.4.1.10 <code>collection.empty?</code>
</h6><p>如果关联数组中没有关联对象，<code>collection.empty?</code> 方法返回 <code>true</code>。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
&lt;% if @part.assemblies.empty? %&gt;
  This part is not used in any assemblies
&lt;% end %&gt;

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection.size">4.4.1.11 <code>collection.size</code>
</h6><p><code>collection.size</code> 返回关联对象数组中的对象数量。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@assembly_count = @part.assemblies.size

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection.find(...)">4.4.1.12 <code>collection.find(...)</code>
</h6><p><code>collection.find</code> 方法在关联对象数组中查找对象，句法和可用选项跟 <code>ActiveRecord::Base.find</code> 方法一样。同时还限制对象必须在集合中。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@assembly = @part.assemblies.find(1)

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection.where(...)">4.4.1.13 <code>collection.where(...)</code>
</h6><p><code>collection.where</code> 方法根据指定的条件在关联对象数组中查找对象，但会惰性加载对象，用到对象时才会执行查询。同时还限制对象必须在集合中。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@new_assemblies = @part.assemblies.where("created_at &gt; ?", 2.days.ago)

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection.exists-questionmark(...)">4.4.1.14 <code>collection.exists?(...)</code>
</h6><p><code>collection.exists?</code> 方法根据指定的条件检查关联对象数组中是否有符合条件的对象，句法和可用选项跟 <code>ActiveRecord::Base.exists?</code> 方法一样。</p><h6 id="collection.build(attributes-=-{})">4.4.1.15 <code>collection.build(attributes = {})</code>
</h6><p><code>collection.build</code> 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会在连接数据表中创建对应的记录，但不会保存关联对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection.create(attributes-=-{})">4.4.1.16 <code>collection.create(attributes = {})</code>
</h6><p><code>collection.create</code> 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会在连接数据表中创建对应的记录，只要能通过所有数据验证，就会保存关联对象。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
@assembly = @part.assemblies.create({assembly_name: "Transmission housing"})

</pre>
</div>
<h6 id="has_and_belongs_to_many-关联添加的方法-collection.create-bang(attributes-=-{})">4.4.1.17 <code>collection.create!(attributes = {})</code>
</h6><p>作用和 <code>collection.create</code> 相同，但如果记录不合法会抛出 <code>ActiveRecord::RecordInvalid</code> 异常。</p><h5 id="has_and_belongs_to_many-方法的选项">4.4.2 <code>has_and_belongs_to_many</code> 方法的选项</h5><p>Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 <code>has_and_belongs_to_many</code> 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies, autosave: true,
                                       readonly: true
end

</pre>
</div>
<p><code>has_and_belongs_to_many</code> 关联支持以下选项：</p>
<ul>
<li><code>:association_foreign_key</code></li>
<li><code>:autosave</code></li>
<li><code>:class_name</code></li>
<li><code>:foreign_key</code></li>
<li><code>:join_table</code></li>
<li><code>:validate</code></li>
<li><code>:readonly</code></li>
</ul>
<h6 id=":association_foreign_key">4.4.2.1 <code>:association_foreign_key</code>
</h6><p>按照约定，在连接数据表中用来指向另一个模型的外键名是模型名后加 <code>_id</code>。<code>:association_foreign_key</code> 选项可以设置要使用的外键名：</p><div class="info"><p><code>:foreign_key</code> 和 <code>:association_foreign_key</code> 这两个选项在设置多对多自连接时很有用。</p></div><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end

</pre>
</div>
<h6 id="has_and_belongs_to_many-方法的选项-:autosave">4.4.2.2 <code>:autosave</code>
</h6><p>如果把 <code>:autosave</code> 选项设为 <code>true</code>，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。</p><h6 id="has_and_belongs_to_many-方法的选项-:class_name">4.4.2.3 <code>:class_name</code>
</h6><p>如果另一个模型无法从关联的名字获取，可以使用 <code>:class_name</code> 选项指定模型名。例如，一个部件由多个装配件组成，但表示装配件的模型是 <code>Gadget</code>，就可以这样声明关联：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
end

</pre>
</div>
<h6 id="has_and_belongs_to_many-方法的选项-:foreign_key">4.4.2.4 <code>:foreign_key</code>
</h6><p>按照约定，在连接数据表中用来指向模型的外键名是模型名后加 <code>_id</code>。<code>:foreign_key</code> 选项可以设置要使用的外键名：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end

</pre>
</div>
<h6 id=":join_table">4.4.2.5 <code>:join_table</code>
</h6><p>如果默认按照字典顺序生成的默认名不能满足要求，可以使用 <code>:join_table</code> 选项指定。</p><h6 id="has_and_belongs_to_many-方法的选项-:validate">4.4.2.6 <code>:validate</code>
</h6><p>如果把 <code>:validate</code> 选项设为 <code>false</code>，保存对象时，不会验证关联对象。该选项的默认值是 <code>true</code>，保存对象验证关联的对象。</p><h5 id="has_and_belongs_to_many-的作用域">4.4.3 <code>has_and_belongs_to_many</code> 的作用域</h5><p>有时可能需要定制 <code>has_and_belongs_to_many</code> 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies, -&gt; { where active: true }
end

</pre>
</div>
<p>在作用域代码块中可以使用任何一个标准的<a href="active_record_querying.html">查询方法</a>。下面分别介绍这几个方法：</p>
<ul>
<li><code>where</code></li>
<li><code>extending</code></li>
<li><code>group</code></li>
<li><code>includes</code></li>
<li><code>limit</code></li>
<li><code>offset</code></li>
<li><code>order</code></li>
<li><code>readonly</code></li>
<li><code>select</code></li>
<li><code>uniq</code></li>
</ul>
<h6 id="has_and_belongs_to_many-的作用域-where">4.4.3.1 <code>where</code>
</h6><p><code>where</code> 方法指定关联对象必须满足的条件。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -&gt; { where "factory = 'Seattle'" }
end

</pre>
</div>
<p>条件还可以使用 Hash 的形式指定：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -&gt; { where factory: 'Seattle' }
end

</pre>
</div>
<p>如果 <code>where</code> 使用 Hash 形式，通过这个关联创建的记录会自动使用 Hash 中的作用域。针对上面的例子，使用 <code>@parts.assemblies.create</code> 或 <code>@parts.assemblies.build</code> 创建订单时，会自动把 <code>factory</code> 字段的值设为 <code>"Seattle"</code>。</p><h6 id="has_and_belongs_to_many-的作用域-extending">4.4.3.2 <code>extending</code>
</h6><p><code>extending</code> 方法指定一个模块名，用来扩展关联代理。<a href="#association-extensions">后文</a>会详细介绍关联扩展。</p><h6 id="has_and_belongs_to_many-的作用域-group">4.4.3.3 <code>group</code>
</h6><p><code>group</code> 方法指定一个属性名，用在 SQL <code>GROUP BY</code> 子句中，分组查询结果。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies, -&gt; { group "factory" }
end

</pre>
</div>
<h6 id="has_and_belongs_to_many-的作用域-includes">4.4.3.4 <code>includes</code>
</h6><p><code>includes</code> 方法指定使用关联时要按需加载的间接关联。</p><h6 id="has_and_belongs_to_many-的作用域-limit">4.4.3.5 <code>limit</code>
</h6><p><code>limit</code> 方法限制通过关联获取的对象数量。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -&gt; { order("created_at DESC").limit(50) }
end

</pre>
</div>
<h6 id="has_and_belongs_to_many-的作用域-offset">4.4.3.6 <code>offset</code>
</h6><p><code>offset</code> 方法指定通过关联获取对象时的偏移量。例如，<code>-&gt; { offset(11) }</code> 会跳过前 11 个记录。</p><h6 id="has_and_belongs_to_many-的作用域-order">4.4.3.7 <code>order</code>
</h6><p><code>order</code> 方法指定获取关联对象时使用的排序方式，用于 SQL <code>ORDER BY</code> 子句。</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Parts &lt; ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -&gt; { order "assembly_name ASC" }
end

</pre>
</div>
<h6 id="has_and_belongs_to_many-的作用域-readonly">4.4.3.8 <code>readonly</code>
</h6><p>如果使用 <code>readonly</code>，通过关联获取的对象就是只读的。</p><h6 id="has_and_belongs_to_many-的作用域-select">4.4.3.9 <code>select</code>
</h6><p><code>select</code> 方法用来覆盖获取关联对象数据的 SQL <code>SELECT</code> 子句。默认情况下，Rails 会读取所有字段。</p><h6 id="uniq">4.4.3.10 <code>uniq</code>
</h6><p><code>uniq</code> 方法用来删除集合中重复的对象。</p><h5 id="has_and_belongs_to_many-关联详解-什么时候保存对象">4.4.4 什么时候保存对象</h5><p>把对象赋值给 <code>has_and_belongs_to_many</code> 关联时，会自动保存对象（因为要更新外键）。如果一次赋值多个对象，所有对象都会自动保存。</p><p>如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 <code>false</code>，赋值操作会取消。</p><p>如果父对象（<code>has_and_belongs_to_many</code> 关联声明所在的模型）没保存（<code>new_record?</code> 方法返回 <code>true</code>），那么子对象也不会保存。只有保存了父对象，才会保存子对象。</p><p>如果赋值给 <code>has_and_belongs_to_many</code> 关联时不想保存对象，可以使用 <code>collection.build</code> 方法。</p><h4 id="关联回调">4.5 关联回调</h4><p>普通回调会介入 Active Record 对象的生命周期，在很多时刻处理对象。例如，可以使用 <code>:before_save</code> 回调在保存对象之前处理对象。</p><p>关联回调和普通回调差不多，只不过由集合生命周期中的事件触发。关联回调有四种：</p>
<ul>
<li><code>before_add</code></li>
<li><code>after_add</code></li>
<li><code>before_remove</code></li>
<li><code>after_remove</code></li>
</ul>
<p>关联回调在声明关联时定义。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders, before_add: :check_credit_limit

  def check_credit_limit(order)
    ...
  end
end

</pre>
</div>
<p>Rails 会把添加或删除的对象传入回调。</p><p>同一事件可触发多个回调，多个回调使用数组指定：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders,
    before_add: [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(order)
    ...
  end

  def calculate_shipping_charges(order)
    ...
  end
end

</pre>
</div>
<p>如果 <code>before_add</code> 回调抛出异常，不会把对象加入集合。类似地，如果 <code>before_remove</code> 抛出异常，对象不会从集合中删除。</p><h4 id="关联扩展">4.6 关联扩展</h4><p>Rails 基于关联代理对象自动创建的功能是死的，但是可以通过匿名模块、新的查询方法、创建对象的方法等进行扩展。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Customer &lt; ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by(region_id: order_number[0..2])
    end
  end
end

</pre>
</div>
<p>如果扩展要在多个关联中使用，可以将其写入具名扩展模块。例如：</p><div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module FindRecentExtension
  def find_recent
    where("created_at &gt; ?", 5.days.ago)
  end
end

class Customer &lt; ActiveRecord::Base
  has_many :orders, -&gt; { extending FindRecentExtension }
end

class Supplier &lt; ActiveRecord::Base
  has_many :deliveries, -&gt; { extending FindRecentExtension }
end

</pre>
</div>
<p>在扩展中可以使用如下 <code>proxy_association</code> 方法的三个属性获取关联代理的内部信息：</p>
<ul>
<li>
<code>proxy_association.owner</code>：返回关联所属的对象；</li>
<li>
<code>proxy_association.reflection</code>：返回描述关联的反射对象；</li>
<li>
<code>proxy_association.target</code>：返回 <code>belongs_to</code> 或 <code>has_one</code> 关联的关联对象，或者 <code>has_many</code> 或 <code>has_and_belongs_to_many</code> 关联的关联对象集合；</li>
</ul>


        <h3>反馈</h3>
        <p>
          欢迎帮忙改善指南质量。
        </p>
        <p>
          如发现任何错误，欢迎修正。开始贡献前，可先行阅读<a href="http://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">贡献指南：文档</a>。
        </p>
        <p>翻译如有错误，深感抱歉，欢迎 <a href="https://github.com/ruby-china/guides/fork">Fork</a> 修正，或至此处<a href="https://github.com/ruby-china/guides/issues/new">回报</a>。</p>
        <p>
          文章可能有未完成或过时的内容。请先检查 <a href="http://edgeguides.rubyonrails.org">Edge Guides</a> 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails 指南准则</a>来了解行文风格。
        </p>
        <p>最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs 邮件群组</a>。
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>本著作采用<a href="https://creativecommons.org/licenses/by-sa/4.0/">创用 CC 姓名标示-相同方式分享 4.0 国际授权条款</a>授权。</p>
<p>“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。</p>

    </div>
  </div>

  <script type="text/javascript" src="javascripts/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/responsive-tables.js"></script>
  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all();
    $(guidesIndex.bind);
  </script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    // ga('create', '', 'ruby-china.github.io');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');

  </script>
</body>
</html>
